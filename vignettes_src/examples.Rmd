---
title: "Examples and use-cases"
author: "Rich FitzJohn"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using docker with stevedore}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

``` {r include = FALSE}
knitr::opts_chunk$set(error = FALSE)
lang_output <- function(x, lang) {
  cat(c(sprintf("```%s", lang), x, "```"), sep="\n")
}
c_output <- function(x) lang_output(x, "cc")
r_output <- function(x) lang_output(x, "r")
plain_output <- function(x) lang_output(x, "plain")
pg_ready <- function(port, host = "localhost", user = "postgres",
                     attempts = 10) {
  f <- function() {
    con <- DBI::dbConnect(RPostgres::Postgres(),
                          host = host, port = port, user = user)
    on.exit(DBI::dbDisconnect(con))
    DBI::dbListTables(con)
    TRUE
  }
  for (i in seq_len(attempts)) {
    if (tryCatch(f(), error = function(e) FALSE)) {
      return()
    }
    Sys.sleep(1)
  }
  stop("postgres not available in time")
}
```

## Using a database in testing

This example requires the `redux` package, which is available on
CRAN and can be installed with

```r
install.packages("redux")
```
``` {r }
docker <- stevedore::docker_client()

redis <- docker$container$run("redis", name = "redis", ports = "6379",
                              detach = TRUE, rm = TRUE)
```

We now have a redis server running on `r redis$ports()$host_port`
``` {r }
redis$ports()
```

Make a connection to the Redis server:
``` {r }
con <- redux::hiredis(port = redis$ports()$host_port)
```

and we can communicate with the Redis server:
``` {r }
con$PING()
```

Because this is a brand new container we can write data without
worrying about clobbering data that already exists:
``` {r }
con$SET("key", "hello redis")
con$GET("key")
```

And we can get a fresh copy of Redis by simply starting a new copy
of redis
``` {r }
redis$kill()
redis <- docker$container$run("redis", name = "redis", ports = "6379",
                              detach = TRUE, rm = TRUE)
con <- redux::hiredis(port = redis$ports()$host_port)
con$KEYS("*")

redis$kill()
```

The same approach works for other database that might be large or
awkward to install
``` {r }
pg <- docker$container$run("postgres", name = "pg", ports = "5432",
                           detach = TRUE, rm = TRUE)
```

``` {r echo = FALSE}
pg_ready(pg$ports()$host_port)
```

Now we have a full Postgres server running and can start writing
data into it without worrying about clobbering anyone elses data.
``` {r }
con <- DBI::dbConnect(RPostgres::Postgres(),
                      host = "localhost",
                      port = pg$ports()$host_port,
                      user = "postgres")
DBI::dbWriteTable(con, "mtcars", mtcars)
```

And if anything goes wrong, you can inspect the logs of the server
easily if the client does not give informative error messages:
``` {r error = TRUE}
DBI::dbWriteTable(con, "mtcars", iris, append = TRUE)
pg$logs(tail = 2)

pg$kill()
```

## Testing shiny apps

(this section is not actually run because doing anything with it
requires looking in a web browser)

The rocker project has a shiny container that provides an easy to
use version of the shiny server.  If we have a directory `app`
that contains a shiny application we can map this with:
``` {r eval = FALSE}
volumes <- sprintf("%s:%s", normalizePath("app"), "/srv/shiny-server/")
```

(see the [shiny docker image
documentation](https://hub.docker.com/r/rocker/shiny) for the
destination path.

We can start this with
``` {r eval = FALSE}
shiny <- docker$container$run("rocker/shiny", name = "shiny", ports = "3838",
                              volumes = volumes,
                              detach = TRUE, rm = TRUE)
```

In an interactive session, you can visit the shiny server:
``` {r eval = FALSE}
browseURL(sprintf("http://localhost:%s", shiny$ports()$host_port))
```

## Package testing

You can build an image that contains all the bits required to test
your package and then run tests using that image.  This ensures
that you're running in a totally clean environment (and that you
really know what all the dependencies of your package are)
``` {r include = FALSE}
local({
  p <- system.file("images/tester", package = "stevedore", mustWork = TRUE)
  stopifnot(file.copy(p, ".", recursive = TRUE))
})
```

For this we have a dockerfile, which contains
``` {r echo = FALSE, results = "asis"}
plain_output(readLines("tester/Dockerfile"))
```

And the script `tester.sh` (copied into the docker image above)
which contains:
``` {r }
lang_output(readLines("tester/tester.sh"), "shell")

img <- docker$image$build("tester", tag = "richfitz/tester")
```

With this image we can then test packages off github:
``` {r }
invisible(docker$container$run(img, "https://github.com/richfitz/ids",
                               rm = TRUE, stream = stdout()))
```

``` {r echo = FALSE}
unlink("tester", recursive = TRUE)
```

(I have cheated here and put all of the dependencies of `ids` into
the docker image via the Dockerfile).

The same approach would work by mounting the package source
directory into the container and passing the path (within the
container) to `$run()`.
